# Hashname

A **hashname** is a unique cryptographic fingerprint that identifies an endpoint in the TNG network. It serves as a portable, self-certified, verifiable addressâ€”analogous to a MAC address but cryptographically secured and self-generated.

## Format

A hashname is always a **52-character lowercase base32 string** representing a 32-byte (256-bit) value:

```
kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq
```

The base32 encoding uses the RFC 4648 alphabet (`a-z`, `2-7`) without padding.

## Properties

- **Unique**: Derived from public keys, statistically unique across all endpoints
- **Self-certified**: No certificate authority required; the holder proves ownership via signatures
- **Verifiable**: Anyone with the public keys can verify the hashname
- **Stable**: Remains constant as long as the underlying keys don't change
- **Multi-algorithm**: Supports multiple cipher suites simultaneously

## Generation Algorithm

A hashname is generated by combining one or more Cipher Set Keys (CSKs) through a rolling SHA-256 hash process.

### Step 1: Collect CSKs

Each endpoint has one or more public keys, each identified by a Cipher Set ID (CSID). For example:

| CSID | Algorithm | CSK (public key bytes) |
|------|-----------|------------------------|
| `4a` | X25519 + Ed25519 | 64 bytes |
| `4b` | ML-KEM-768 + X25519 + Ed25519 | 1248 bytes |
| `3a` | Curve25519 | 32 bytes |

### Step 2: Generate Intermediate Hashes

For each CSK, compute an intermediate hash:

```
intermediate[csid] = SHA-256(CSK)
```

These 32-byte intermediate values can be shared instead of the full public keys to reduce bandwidth when verifying hashnames.

### Step 3: Rollup Hash

Sort CSIDs in ascending order (lexicographic on the hex value), then perform a rolling hash:

```python
def generate_hashname(csks: dict[str, bytes]) -> bytes:
    # Sort CSIDs: "1a" < "2a" < "3a" < "4a" < "4b"
    sorted_csids = sorted(csks.keys())
    
    hash_value = b''
    for csid in sorted_csids:
        # Hash the CSID byte
        csid_byte = bytes.fromhex(csid)
        if hash_value:
            hash_value = sha256(hash_value + csid_byte)
        else:
            hash_value = sha256(csid_byte)
        
        # Hash in the intermediate value
        intermediate = sha256(csks[csid])
        hash_value = sha256(hash_value + intermediate)
    
    return hash_value  # 32 bytes
```

### Example

Given an endpoint with CS4a and CS3a keys:

```python
csks = {
    "3a": bytes.fromhex("97d8...7101"),  # 32-byte Curve25519 key
    "4a": bytes.fromhex("21b6...f350"),  # 64-byte X25519+Ed25519 keys
}

# Step 1: Compute intermediates
intermediate_3a = sha256(csks["3a"])  # 32 bytes
intermediate_4a = sha256(csks["4a"])  # 32 bytes

# Step 2: Rollup (3a < 4a in sort order)
hash = sha256(b'\x3a')                      # Hash CSID 0x3a
hash = sha256(hash + intermediate_3a)       # Hash in 3a intermediate
hash = sha256(hash + b'\x4a')               # Hash in CSID 0x4a  
hash = sha256(hash + intermediate_4a)       # Hash in 4a intermediate

# Step 3: Encode as base32
hashname = base32_encode(hash).lower()
# Result: "kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq"
```

## Verification

To verify a hashname:

1. Obtain the claimed public keys (CSKs) or intermediate hashes
2. Recompute the hashname using the generation algorithm
3. Compare with the claimed hashname

If they match, the hashname is valid for those keys.

## Intermediate Hash Exchange

When bandwidth is limited, endpoints can exchange intermediate hashes instead of full public keys:

```json
{
  "hashname": "kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq",
  "intermediates": {
    "3a": "eg3fxl...6nia",
    "4a": "ckcz...em6q"
  },
  "keys": {
    "4a": "21b6...f350"
  }
}
```

The recipient:
1. Uses the provided `4a` key for the handshake
2. Verifies the hashname matches by computing the rollup with:
   - `intermediate_3a` from `intermediates`
   - `sha256(keys["4a"])` computed locally

This allows verification without transferring all keys.

## DID Compatibility

Hashnames can be represented as W3C Decentralized Identifiers using the `did:th` method:

```
did:th:kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq
```

### DID Document

A TNG endpoint's DID document contains its public keys and service endpoints:

```json
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:th:kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq",
  "verificationMethod": [
    {
      "id": "did:th:kw3a...7kkq#cs4a",
      "type": "X25519KeyAgreementKey2020",
      "publicKeyMultibase": "z6LSb..."
    },
    {
      "id": "did:th:kw3a...7kkq#cs4a-sign",
      "type": "Ed25519VerificationKey2020",
      "publicKeyMultibase": "z6Mkp..."
    }
  ],
  "service": [
    {
      "id": "did:th:kw3a...7kkq#tng",
      "type": "TelehashEndpoint",
      "serviceEndpoint": "quic://192.168.1.100:42424"
    }
  ]
}
```

## Best Practices

### Key Storage

- Store private keys securely (hardware security module, secure enclave, encrypted file)
- Back up keys to prevent identity loss
- Consider key rotation strategies for long-lived identities

### Hashname Sharing

- Share hashnames freely; they reveal nothing about the keys themselves
- Include at least one CSK or intermediate when sharing for verification
- Use URIs for out-of-band sharing: `tng://kw3a...7kkq?cs4a=base32key`

### Multi-Device Identity

- Same hashname across devices requires sharing private keys (security risk)
- Prefer unique hashname per device with application-layer identity linking
- Use DIDs for higher-level identity that spans multiple hashnames

## Validation

A valid hashname must:

1. Be exactly 52 characters
2. Contain only lowercase base32 characters (`a-z`, `2-7`)
3. Decode to exactly 32 bytes
4. Match the SHA-256 rollup of the claimed keys

```python
import re

def is_valid_hashname_format(s: str) -> bool:
    if len(s) != 52:
        return False
    if not re.match(r'^[a-z2-7]+$', s):
        return False
    return True
```

## Security Considerations

- **Collision resistance**: SHA-256 provides ~128 bits of collision resistance
- **Pre-image resistance**: Cannot derive keys from hashname
- **No anonymity**: Hashnames are persistent identifiers; use different hashnames for different contexts if anonymity is needed
- **Key compromise**: If private keys are compromised, generate new keys and hashname

---

*Related: [Cipher Suites](cipher-suites.md) | [Links](links.md) | [E3X](e3x.md)*
