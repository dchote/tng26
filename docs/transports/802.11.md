# 802.11 WiFi Physical Layer

**802.11 (WiFi)** provides high-bandwidth local area connectivity. While WiFi typically operates with IP, TNG can use WiFi's data link layer directly for mesh networking without infrastructure.

## Overview

| Property | Value |
|----------|-------|
| **Standard** | IEEE 802.11 (a/b/g/n/ac/ax) |
| **Frequency** | 2.4 GHz, 5 GHz, 6 GHz |
| **Range** | 50-100 meters indoor |
| **Data Rate** | 1 Mbps - 1+ Gbps |
| **MTU** | 2304 bytes |

## Operating Modes

### Infrastructure Mode (with QUIC)

When WiFi infrastructure is available, use [QUIC transport](quic.md) over IP. This is the preferred mode for most scenarios.

### Ad-Hoc Mode (IBSS)

Direct device-to-device without access point:

```python
# Linux: Create ad-hoc network
iw dev wlan0 set type ibss
iw dev wlan0 ibss join TNG-MESH 2412  # Channel 1

# Configure IP (optional, for hybrid operation)
ip addr add 169.254.x.x/16 dev wlan0
```

### WiFi Direct (P2P)

Peer-to-peer connections with WPS:

```python
# Enable WiFi Direct
wpa_cli p2p_find
wpa_cli p2p_connect <peer_mac> pbc
```

### 802.11s Mesh

Native WiFi mesh networking:

```bash
# Linux: Enable mesh mode
iw dev wlan0 set type mesh
iw dev wlan0 mesh join TNG-MESH

# Configure mesh parameters
iw dev wlan0 set mesh_param mesh_hwmp_rootmode=1
```

## Path Format

```json
{
  "type": "802.11",
  "bssid": "AA:BB:CC:DD:EE:FF",
  "channel": 6,
  "mode": "adhoc"
}
```

### Mode Values

| Mode | Description |
|------|-------------|
| `adhoc` | Ad-hoc (IBSS) mode |
| `p2p` | WiFi Direct |
| `mesh` | 802.11s mesh |

## Frame Format

When operating at Layer 2 (without IP):

### Data Frame

```
┌───────────────────────────────────────────────────────────────────┐
│ Frame Control │ Duration │ Addr1 │ Addr2 │ Addr3 │ Seq │ Payload │
│    (2B)       │   (2B)   │ (6B)  │ (6B)  │ (6B)  │(2B) │ (0-2304)│
└───────────────────────────────────────────────────────────────────┘
```

### EtherType

For raw Ethernet frames, use custom EtherType:

```
TNG EtherType: 0x88B5 (Local Experimental)
```

### Frame Construction

```python
def build_wifi_frame(dest_mac: bytes, src_mac: bytes, payload: bytes) -> bytes:
    """Build raw WiFi data frame"""
    ethertype = b'\x88\xB5'  # TNG custom type
    
    frame = dest_mac + src_mac + ethertype + payload
    return frame
```

## Discovery

### Beacon Frames

In ad-hoc or mesh mode, devices broadcast beacons:

```python
# Beacon Information Elements
beacon_ies = {
    "SSID": "TNG-MESH",
    "Vendor Specific": {
        "OUI": "00:00:00",  # TNG OUI (placeholder)
        "Data": hashname[:8]  # First 8 bytes of hashname
    }
}
```

### Probe Requests

Active scanning for TNG networks:

```python
async def scan_for_tng_networks():
    """Scan for TNG-enabled WiFi networks"""
    # Trigger scan
    subprocess.run(["iw", "dev", "wlan0", "scan"])
    
    # Parse results
    networks = []
    for bss in parse_scan_results():
        if bss.ssid.startswith("TNG-") or has_tng_vendor_ie(bss):
            networks.append({
                "bssid": bss.bssid,
                "channel": bss.channel,
                "rssi": bss.rssi,
            })
    
    return networks
```

## Channel Selection

### 2.4 GHz Channels

| Channel | Frequency | Overlap |
|---------|-----------|---------|
| 1 | 2412 MHz | - |
| 6 | 2437 MHz | - |
| 11 | 2462 MHz | - |

Use channels 1, 6, or 11 to avoid overlap.

### 5 GHz Channels

| Channel | Frequency | DFS |
|---------|-----------|-----|
| 36 | 5180 MHz | No |
| 40 | 5200 MHz | No |
| 44 | 5220 MHz | No |
| 48 | 5240 MHz | No |
| 52-64 | Various | Yes |
| 100-144 | Various | Yes |
| 149-165 | Various | No |

### Dynamic Channel Selection

```python
def select_channel(scan_results: list) -> int:
    """Select least congested channel"""
    channel_usage = defaultdict(int)
    
    for bss in scan_results:
        channel_usage[bss.channel] += 1
    
    # Prefer non-overlapping 2.4 GHz channels
    preferred = [1, 6, 11, 36, 40, 44, 48]
    
    for channel in preferred:
        if channel_usage[channel] == 0:
            return channel
    
    # Return least used
    return min(preferred, key=lambda c: channel_usage[c])
```

## Implementation

### Raw Socket (Linux)

```python
import socket

def create_raw_wifi_socket(interface: str) -> socket.socket:
    """Create raw socket for WiFi frames"""
    sock = socket.socket(
        socket.AF_PACKET,
        socket.SOCK_RAW,
        socket.htons(0x88B5)  # TNG EtherType
    )
    sock.bind((interface, 0))
    return sock

async def send_frame(sock, dest_mac: bytes, payload: bytes):
    src_mac = get_interface_mac(sock.getsockname()[0])
    frame = build_wifi_frame(dest_mac, src_mac, payload)
    sock.send(frame)

async def receive_frame(sock) -> tuple[bytes, bytes]:
    frame = sock.recv(2400)
    dest_mac = frame[0:6]
    src_mac = frame[6:12]
    payload = frame[14:]
    return src_mac, payload
```

### Using wpa_supplicant

For WiFi Direct:

```python
import asyncio

class WpaSupplicantClient:
    async def connect(self, socket_path="/var/run/wpa_supplicant/wlan0"):
        self.reader, self.writer = await asyncio.open_unix_connection(socket_path)
    
    async def command(self, cmd: str) -> str:
        self.writer.write(f"{cmd}\n".encode())
        return (await self.reader.readline()).decode()
    
    async def p2p_find(self):
        return await self.command("P2P_FIND")
    
    async def p2p_connect(self, peer_mac: str):
        return await self.command(f"P2P_CONNECT {peer_mac} pbc")
```

## Power Management

### Power Save Mode

```python
# Enable power save
iw dev wlan0 set power_save on

# Disable for low latency
iw dev wlan0 set power_save off
```

### Wake-on-Wireless

For devices that support it:

```bash
# Enable wake on specific patterns
iw phy phy0 wowlan enable magic-packet patterns <pattern>
```

## Integration with QUIC

When IP is available, prefer QUIC:

```python
def select_wifi_transport(network_state):
    """Choose between raw WiFi and QUIC"""
    if network_state.has_ip:
        # Use QUIC for better performance
        return QUICTransport(network_state.ip, 42424)
    else:
        # Fall back to raw WiFi
        return WiFiRawTransport(network_state.interface)
```

## Mesh Networking (802.11s)

### Mesh Configuration

```bash
# Create mesh interface
iw dev wlan0 interface add mesh0 type mesh

# Join mesh
iw dev mesh0 mesh join TNG-MESH freq 2437

# Set mesh ID
iw dev mesh0 set meshid TNG-MESH
```

### Mesh Path Selection

802.11s uses HWMP (Hybrid Wireless Mesh Protocol):

```bash
# Configure as root (gateway)
iw dev mesh0 set mesh_param mesh_hwmp_rootmode=2

# Set path refresh time
iw dev mesh0 set mesh_param mesh_path_refresh_time=1000
```

## Security Considerations

### Encryption

- Raw WiFi frames are unencrypted at Layer 2
- E3X provides end-to-end encryption
- Consider WPA3 for additional link-layer security

### MAC Address Privacy

```bash
# Enable MAC randomization
iw dev wlan0 set addr_randomization_scan enable
```

## Error Handling

| Error | Cause | Action |
|-------|-------|--------|
| `ENETDOWN` | Interface down | Bring up interface |
| `ENODEV` | Interface missing | Check hardware |
| `EBUSY` | Channel in use | Select different channel |

---

*Related: [Transport Overview](README.md) | [QUIC](quic.md) | [802.15.4](802.15.4.md)*
