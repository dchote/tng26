# 802.15.4 Physical Layer (Zigbee/Thread)

**IEEE 802.15.4** is the foundation for low-power wireless protocols like Zigbee, Thread, and 6LoWPAN. It's ideal for battery-powered IoT devices requiring mesh networking.

## Overview

| Property | Value |
|----------|-------|
| **Standard** | IEEE 802.15.4-2020 |
| **Frequency** | 2.4 GHz (worldwide), 868/915 MHz |
| **Range** | 10-100 meters |
| **Data Rate** | 250 kbps (2.4 GHz) |
| **MTU** | 127 bytes |

## Why 802.15.4?

| Feature | Benefit |
|---------|---------|
| **Low power** | Years on battery |
| **Mesh capable** | Self-healing networks |
| **Widespread** | Many chipsets available |
| **Standards-based** | Interoperable |

## Path Format

```json
{
  "type": "802.15.4",
  "pan_id": "0x1234",
  "short_addr": "0x5678",
  "channel": 15
}
```

### Extended Address Format

```json
{
  "type": "802.15.4",
  "pan_id": "0x1234",
  "extended_addr": "00:11:22:33:44:55:66:77",
  "channel": 15
}
```

## Addressing

### Address Types

| Type | Size | Usage |
|------|------|-------|
| Short | 2 bytes | After association |
| Extended | 8 bytes | IEEE EUI-64 |

### PAN ID

Personal Area Network identifier (16-bit):

```python
# Reserved PAN IDs
BROADCAST_PAN = 0xFFFF

# Generate random PAN ID
import random
pan_id = random.randint(0x0001, 0xFFFE)
```

### Address Assignment

```python
class AddressManager:
    def __init__(self):
        self.next_short_addr = 0x0001
        self.address_map = {}  # hashname -> short_addr
    
    def assign_address(self, hashname: str) -> int:
        if hashname in self.address_map:
            return self.address_map[hashname]
        
        addr = self.next_short_addr
        self.next_short_addr += 1
        self.address_map[hashname] = addr
        return addr
```

## Frame Format

### MAC Frame

```
┌────────────────────────────────────────────────────────────────────┐
│ FCF  │ Seq │ Dest PAN │ Dest Addr │ Src PAN │ Src Addr │ Payload  │
│ (2B) │(1B) │   (2B)   │  (2/8B)   │  (2B)   │  (2/8B)  │(0-102B)  │
└────────────────────────────────────────────────────────────────────┘
```

### Frame Control Field

| Bits | Field | Description |
|------|-------|-------------|
| 0-2 | Frame Type | 001 = Data |
| 3 | Security | 0 = Disabled (E3X handles) |
| 4 | Frame Pending | More data waiting |
| 5 | Ack Request | Request acknowledgment |
| 6 | PAN ID Compression | Omit source PAN |
| 10-11 | Dest Addr Mode | 10=Short, 11=Extended |
| 14-15 | Src Addr Mode | 10=Short, 11=Extended |

### Maximum Payload

With short addresses and PAN compression:
```
127 - 2 (FCF) - 1 (Seq) - 2 (Dest PAN) - 2 (Dest) - 2 (Src) - 2 (FCS) = 116 bytes
```

TNG uses 102 bytes to allow for security headers if needed.

## Chunking

Due to 127-byte MTU, TNG packets must be chunked:

### Chunk Header

```
Byte 0: [FIRST:1][LAST:1][SEQ:6]
Byte 1: [LENGTH_HIGH] (first chunk only)
Byte 2: [LENGTH_LOW]  (first chunk only)
```

### Chunking Parameters

| Parameter | Value |
|-----------|-------|
| MTU | 127 bytes |
| Header (first) | 3 bytes |
| Header (cont) | 1 byte |
| Payload (first) | 99 bytes |
| Payload (cont) | 101 bytes |
| Max chunks | 64 |
| Max packet | ~6 KB |

### Implementation

```python
def chunk_for_802154(packet: bytes) -> list[bytes]:
    """Chunk packet for 802.15.4 transmission"""
    FIRST_PAYLOAD = 99
    CONT_PAYLOAD = 101
    
    chunks = []
    offset = 0
    seq = 0
    total_len = len(packet)
    
    while offset < total_len:
        is_first = (offset == 0)
        payload_size = FIRST_PAYLOAD if is_first else CONT_PAYLOAD
        
        chunk_data = packet[offset:offset + payload_size]
        is_last = (offset + payload_size >= total_len)
        
        header = (seq & 0x3F)
        if is_first:
            header |= 0x80
        if is_last:
            header |= 0x40
        
        if is_first:
            chunk = bytes([header, (total_len >> 8) & 0xFF, total_len & 0xFF])
        else:
            chunk = bytes([header])
        
        chunk += chunk_data
        chunks.append(chunk)
        
        offset += payload_size
        seq = (seq + 1) & 0x3F
    
    return chunks
```

## Channels

### 2.4 GHz Band (Worldwide)

| Channel | Frequency |
|---------|-----------|
| 11 | 2405 MHz |
| 12 | 2410 MHz |
| ... | ... |
| 26 | 2480 MHz |

### 868 MHz Band (Europe)

| Channel | Frequency |
|---------|-----------|
| 0 | 868.3 MHz |

### 915 MHz Band (Americas)

| Channel | Frequency |
|---------|-----------|
| 1-10 | 906-924 MHz |

### Channel Selection

```python
def scan_channels() -> dict[int, int]:
    """Scan channels for energy levels"""
    energy = {}
    for channel in range(11, 27):
        set_channel(channel)
        energy[channel] = measure_energy()
    return energy

def select_channel(scan_results: dict[int, int]) -> int:
    """Select channel with lowest interference"""
    return min(scan_results, key=scan_results.get)
```

## Discovery

### Beacon Request

```python
async def send_beacon_request():
    """Send beacon request to discover networks"""
    frame = build_mac_frame(
        frame_type=BEACON_REQUEST,
        dest_pan=BROADCAST_PAN,
        dest_addr=BROADCAST_ADDR,
    )
    await radio.send(frame)
```

### Beacon Response

```python
def build_beacon_payload(mesh):
    """Build beacon payload with TNG info"""
    return {
        "pan_id": mesh.pan_id,
        "hashname": mesh.hashname[:8],  # First 8 bytes
        "capacity": mesh.available_slots,
    }
```

### Active Scan

```python
async def active_scan(channels: list[int] = None):
    """Perform active scan across channels"""
    if channels is None:
        channels = range(11, 27)
    
    networks = []
    for channel in channels:
        set_channel(channel)
        await send_beacon_request()
        
        responses = await receive_with_timeout(0.1)
        for response in responses:
            networks.append({
                "channel": channel,
                "pan_id": response.pan_id,
                "coordinator": response.src_addr,
            })
    
    return networks
```

## Implementation

### Linux (wpan-tools)

```bash
# Create wpan interface
iwpan dev wpan0 set pan_id 0x1234
iwpan dev wpan0 set short_addr 0x0001
iwpan dev wpan0 set channel 15

# Create network interface
ip link add link wpan0 name lowpan0 type lowpan
ip link set lowpan0 up
```

### Embedded (Zephyr/RIOT)

```c
// Zephyr example
#include <zephyr/net/ieee802154_radio.h>

const struct device *radio = DEVICE_DT_GET(DT_CHOSEN(zephyr_ieee802154));

int init_802154(void) {
    struct ieee802154_config config = {
        .pan_id = 0x1234,
        .short_addr = 0x0001,
        .channel = 15,
    };
    
    return ieee802154_configure(radio, IEEE802154_CONFIG_ALL, &config);
}
```

### Python (scapy)

```python
from scapy.layers.dot15d4 import *

def send_802154_frame(radio, dest_addr: int, payload: bytes):
    """Send 802.15.4 frame using scapy"""
    frame = Dot15d4FCS() / Dot15d4Data(
        dest_panid=PAN_ID,
        dest_addr=dest_addr,
        src_addr=MY_ADDR,
    ) / Raw(payload)
    
    radio.send(frame)
```

## Thread Integration

Thread is an IPv6-based protocol over 802.15.4:

### When to Use Thread

- Need IPv6/UDP connectivity
- Interoperability with Thread devices
- Use OpenThread stack

### TNG over Thread

```python
# If Thread network available, use UDP
if thread_available:
    # Use standard QUIC transport over Thread's UDP
    transport = QUICTransport(thread_ip, 42424)
else:
    # Use raw 802.15.4
    transport = IEEE802154Transport(radio)
```

## Power Management

### Duty Cycling

```python
class DutyCycledRadio:
    def __init__(self, radio, wake_interval=1.0, wake_duration=0.1):
        self.radio = radio
        self.wake_interval = wake_interval
        self.wake_duration = wake_duration
    
    async def run(self):
        while True:
            # Wake period
            self.radio.set_rx_mode()
            await asyncio.sleep(self.wake_duration)
            
            # Sleep period
            self.radio.sleep()
            await asyncio.sleep(self.wake_interval - self.wake_duration)
```

### Synchronized Sleep

For mesh networks, synchronize wake times:

```python
def calculate_wake_slot(base_time: float, slot_duration: float, node_id: int) -> float:
    """Calculate synchronized wake slot"""
    slots_per_cycle = 16
    my_slot = node_id % slots_per_cycle
    cycle_time = slots_per_cycle * slot_duration
    
    current_cycle = int((time.time() - base_time) / cycle_time)
    next_wake = base_time + (current_cycle * cycle_time) + (my_slot * slot_duration)
    
    if next_wake < time.time():
        next_wake += cycle_time
    
    return next_wake
```

## Coexistence

### WiFi Coexistence

802.15.4 and WiFi share 2.4 GHz:

| WiFi Channel | 802.15.4 Channels |
|--------------|-------------------|
| 1 | Avoid 11-14 |
| 6 | Avoid 16-18 |
| 11 | Avoid 21-24 |

```python
def select_non_conflicting_channel(wifi_channel: int) -> int:
    """Select 802.15.4 channel avoiding WiFi interference"""
    if wifi_channel == 1:
        return 25  # Use channel 25-26
    elif wifi_channel == 6:
        return 15  # Use channel 15
    elif wifi_channel == 11:
        return 25  # Use channel 25-26
    else:
        return 20  # Default
```

## Security

### Link-Layer Security

802.15.4 supports AES-CCM, but TNG relies on E3X:

```python
# Disable 802.15.4 security (E3X handles encryption)
frame_control.security_enabled = False
```

### Frame Counter

For replay protection at MAC layer:

```python
class FrameCounter:
    def __init__(self):
        self.counter = 0
        self.seen = set()
    
    def next(self) -> int:
        self.counter += 1
        return self.counter
    
    def validate(self, counter: int) -> bool:
        if counter in self.seen:
            return False
        self.seen.add(counter)
        return True
```

---

*Related: [Transport Overview](README.md) | [LoRa](lora.md) | [433/915MHz](uart-radio.md)*
